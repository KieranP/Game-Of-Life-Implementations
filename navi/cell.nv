struct Cell {
  x: int,
  y: int,
  alive: bool,
  next_state: bool? = nil,
  neighbours: [Cell] = [],
}

impl Cell {
  fn new(x: int, y: int, alive: bool): Cell {
    return Cell { x, y, alive };
  }

  fn to_char(self): char {
    if (self.alive) {
      return 'o';
    } else {
      return ' ';
    }
  }

  // Implement first using filter/lambda if available. Then implement
  // foreach and for. Use whatever implementation runs the fastest
  fn alive_neighbours(self): int {
    // The following works but is slower
    // return self.neighbours.filter(|neighbour| {
    //   return neighbour.alive;
    // }).len();

    // The following was the fastest method
    let alive_neighbours = 0;
    for (let neighbour in self.neighbours) {
      if (neighbour.alive) {
        alive_neighbours += 1;
      }
    }
    return alive_neighbours;

    // The following works but is slower
    // let alive_neighbours = 0;
    // for (let i in 0..self.neighbours.len()) {
    //   let neighbour = self.neighbours[i];
    //   if (neighbour.alive) {
    //     alive_neighbours += 1;
    //   }
    // }
    // return alive_neighbours;
  }
}
