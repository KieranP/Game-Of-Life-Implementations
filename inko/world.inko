import cell (Cell)
import std.rand (Random)
import std.string (StringBuffer)

let DIRECTIONS = [
  [-1, 1],  [0, 1],  [1, 1], # above
  [-1, 0],           [1, 0], # sides
  [-1, -1], [0, -1], [1, -1] # below
]

class pub World {
  let pub mut @tick: Int
  let @width: Int
  let @height: Int
  let @cells: Map[String, Cell]

  fn pub static new(width: Int, height: Int) -> World {
    let world = World(
      tick: 0,
      width: width,
      height: height,
      cells: Map.new,
    )

    world.populate_cells
    world.prepopulate_neighbours
    world
  }

  fn pub mut _tick {
    # First determine the action for all cells
    @cells.iter_mut.each(fn (entry) {
      let cell = entry.value
      let alive_neighbours = cell.alive_neighbours()
      if cell.alive == false and alive_neighbours == 3 {
        cell.next_state = true
      } else if alive_neighbours < 2 or alive_neighbours > 3 {
        cell.next_state = false
      } else {
        cell.next_state = cell.alive
      }
    })

    # Then execute the determined action for all cells
    @cells.iter_mut.each(fn (entry) {
      let cell = entry.value
      cell.alive = cell.next_state
    })

    @tick += 1
  }

  # Implement first using string concatenation. Then implement any
  # special string builders, and use whatever runs the fastest
  fn pub render -> String {
    # The following works but it slower
    # let mut rendering = ""
    # let mut y = 0
    # while y < @height {
    #   let mut x = 0
    #   while x < @width {
    #     let cell = cell_at(x, y)
    #     if cell.some? {
    #       rendering += cell.get.to_char
    #     }
    #     x += 1
    #   }
    #   rendering += "\n"
    #   y += 1
    # }
    # rendering

    # The following works but it slower
    # let mut rendering = []
    # let mut y = 0
    # while y < @height {
    #   let mut x = 0
    #   while x < @width {
    #     let cell = cell_at(x, y)
    #     if cell.some? {
    #       rendering.push(cell.get.to_char)
    #     }
    #     x += 1
    #   }
    #   rendering.push("\n")
    #   y += 1
    # }
    # String.join(rendering.iter, with: '')

    # The following was the fastest method
    let rendering = StringBuffer.new
    let mut y = 0
    while y < @height {
      let mut x = 0
      while x < @width {
        let cell = cell_at(x, y)
        if cell.some? {
          rendering.push(cell.get.to_char)
        }
        x += 1
      }
      rendering.push("\n")
      y += 1
    }
    rendering.to_string
  }

  fn cell_at(x: Int, y: Int) -> Option[ref Cell] {
    @cells.opt("${x}-${y}")
  }

  fn mut populate_cells {
    let rng = Random.new
    let mut y = 0
    while y < @height {
      let mut x = 0
      while x < @width {
        let alive = rng.float <= 0.2
        add_cell(x, y, alive)
        x += 1
      }
      y += 1
    }
  }

  fn mut add_cell(x: Int, y: Int, alive: Bool) -> Bool {
    if cell_at(x, y).some? {
      panic("LocationOccupied(${x}-${y})")
    }

    let cell = Cell.new(x, y, alive)
    @cells.set("${x}-${y}", cell)
    true
  }

  fn mut prepopulate_neighbours {
    @cells.iter_mut.each(fn (entry) {
      let cell = entry.value
      DIRECTIONS.iter.each(fn (set) {
        let neighbour = cell_at(
          cell.x + set.get(0),
          cell.y + set.get(1)
        )

        if neighbour.some? {
          cell.neighbours.push(neighbour.get)
        }
      })
    })
  }
}
