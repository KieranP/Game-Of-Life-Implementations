import cell (Cell)
import std.rand (Random)
import std.string (StringBuffer)

let DIRECTIONS = [
  [-1, 1],  [0, 1],  [1, 1], # above
  [-1, 0],           [1, 0], # sides
  [-1, -1], [0, -1], [1, -1] # below
]

type pub World {
  let pub mut @tick: Int
  let @width: Int
  let @height: Int
  let @cells: Map[String, Cell]

  fn pub static new(width: Int, height: Int) -> World {
    let world = World(
      tick: 0,
      width: width,
      height: height,
      cells: Map.new,
    )

    world.populate_cells
    world.prepopulate_neighbours
    world
  }

  fn pub mut dotick {
    # First determine the action for all cells
    for (_, cell) in @cells.iter_mut {
      let alive_neighbours = cell.alive_neighbours()
      if cell.alive == false and alive_neighbours == 3 {
        cell.next_state = true
      } else if alive_neighbours < 2 or alive_neighbours > 3 {
        cell.next_state = false
      } else {
        cell.next_state = cell.alive
      }
    }

    # Then execute the determined action for all cells
    for (_, cell) in @cells.iter_mut {
      cell.alive = cell.next_state
    }

    @tick += 1
  }

  fn pub render -> String {
    # The following is slower
    # let mut rendering = ""
    # let mut y = 0
    # while y < @height {
    #   let mut x = 0
    #   while x < @width {
    #     let cell = cell_at(x, y)
    #     if cell.some? {
    #       rendering += cell.get.to_char
    #     }
    #     x += 1
    #   }
    #   rendering += "\n"
    #   y += 1
    # }
    # rendering

    # The following is slower
    # let mut rendering = []
    # let mut y = 0
    # while y < @height {
    #   let mut x = 0
    #   while x < @width {
    #     let cell = cell_at(x, y)
    #     if cell.some? {
    #       rendering.push(cell.get.to_char)
    #     }
    #     x += 1
    #   }
    #   rendering.push("\n")
    #   y += 1
    # }
    # String.join(rendering.iter, with: '')

    # The following is the fastest
    let rendering = StringBuffer.new
    let mut y = 0
    while y < @height {
      let mut x = 0
      while x < @width {
        let cell = cell_at(x, y)
        if cell.some? {
          rendering.push(cell.get.to_char)
        }
        x += 1
      }
      rendering.push("\n")
      y += 1
    }
    rendering.into_string
  }

  fn cell_at(x: Int, y: Int) -> Option[ref Cell] {
    @cells.get("${x}-${y}").ok
  }

  fn mut populate_cells {
    let rng = Random.new
    let mut y = 0
    while y < @height {
      let mut x = 0
      while x < @width {
        let alive = rng.float <= 0.2
        add_cell(x, y, alive)
        x += 1
      }
      y += 1
    }
  }

  fn mut add_cell(x: Int, y: Int, alive: Bool) -> Bool {
    let existing = cell_at(x, y)
    if existing.some? {
      panic("LocationOccupied(${x}-${y})")
    }

    let cell = Cell.new(x, y, alive)
    @cells.set("${x}-${y}", cell)
    true
  }

  fn mut prepopulate_neighbours {
    for (_, cell) in @cells.iter_mut {
      let x = cell.x
      let y = cell.y

      for set in DIRECTIONS.iter {
        let nx = x + set.get(0).get
        let ny = y + set.get(1).get
        if nx < 0 or ny < 0 {
          next # Out of bounds
        }

        if nx >= @width or ny >= @height {
          next # Out of bounds
        }

        let neighbour = cell_at(nx, ny)
        if neighbour.some? {
          cell.neighbours.push(neighbour.get)
        }
      }
    }
  }
}
